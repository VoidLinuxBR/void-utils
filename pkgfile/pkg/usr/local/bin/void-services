#!/usr/bin/env bash
#shellcheck disable=SC2016,SC2154,SC2155,SC2145,SC2034,SC2001,SC2317,SC2207,SC2164,SC2059

#  void-services
#  Created: 2023/01/23
#  Altered: 2024/03/08
#  Updated: seg 19 jan 2026 19:07:55 -04
#
#  Copyright (c) 2022-2024, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
############################################################################
export LANGUAGE="${LANGUAGE:-pt_BR}"
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=void-services

#debug
export PS4=$'${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
#set -x

#system
readonly APP="${0##*/}"
readonly _VERSION_='1.1.19-20260119'
readonly distro=$(uname -n)
readonly DEPENDENCIES=(gettext dialog cat sed grep)
declare -i quiet=0
declare -i grafico=1
declare -i ncontador=0
declare -i STEP_COUNT=10
declare Interrupted="$(gettext "Interrompido! Saindo...")"
trap 'printf "\n${red}$Interrupted\n"; cleanup; exit 0' INT TERM HUP

cleanup() {
	info_msg "${yellow}$(gettext "Removindo arquivos temporários")...${reset}"
	rm -f "$BOOTLOG"
	sh_enableprintk
	exit 1
}

sh_check_terminal() { [ ! -t 1 ] && use_color=false; }

sh_setvarcolors() {
	sh_check_terminal
	# does the terminal support true-color?
	if [[ -n "$(command -v "tput")" ]]; then
		#tput setaf 127 | cat -v  #capturar saida
		: "${RED=$(tput bold)$(tput setaf 196)}"
		: "${GREEN=$(tput bold)$(tput setaf 2)}"
		: "${YELLOW=$(tput bold)$(tput setaf 3)}"
		: "${BLUE=$(tput setaf 4)}"
		: "${PURPLE=$(tput setaf 125)}"
		: "${CYAN=$(tput setaf 6)}"
		: "${NC=$(tput sgr0)}"
		: "${RESET=$(tput sgr0)}"
		: "${BOLD=$(tput bold)}"
		: "${black=$(tput bold)$(tput setaf 0)}"
		: "${reverse=$(tput rev)}"
		: "${branca=${black}$(tput setab 7)}"

		: "${reset=$(tput sgr0)}"
		: "${rst=$(tput sgr0)}"
		: "${bold=$(tput bold)}"
		: "${underline=$(tput smul)}"
		: "${nounderline=$(tput rmul)}"
		: "${reverse=$(tput rev)}"

		: "${black=$(tput bold)$(tput setaf 0)}"
		: "${red=$(tput bold)$(tput setaf 196)}"
		: "${green=$(tput bold)$(tput setaf 2)}"
		: "${yellow=$(tput bold)$(tput setaf 3)}"
		: "${blue=$(tput setaf 27)}"
		: "${pink=$(tput setaf 5)}"
		: "${magenta=$(tput setaf 5)}"
		: "${cyan=$(tput setaf 6)}"
		: "${white=$(tput setaf 7)}"
		: "${gray=$(tput setaf 8)}"
		: "${light_red=$(tput setaf 9)}"
		: "${light_green=$(tput setaf 10)}"
		: "${light_yellow=$(tput setaf 11)}"
		: "${light_blue=$(tput setaf 12)}"
		: "${light_magenta=$(tput setaf 13)}"
		: "${light_cyan=$(tput setaf 14)}"
		: "${light_white=$(tput setaf 15)}"
		: "${orange=$(tput setaf 202)}"
		: "${purple=$(tput setaf 125)}"
		: "${violet=$(tput setaf 61)}"

		# Definir cores de fundo
		: "${preto=$(tput setab 0)}"
		: "${vermelho=$(tput setab 196)}"
		: "${verde=$(tput setab 2)}"
		: "${amarelo=$(tput setab 3)}"
		: "${azul=$(tput setab 20)}"
		: "${roxo=$(tput setab 5)}"
		: "${ciano=$(tput setab 6)}"
		: "${branca="${black}$(tput setab 7)"}"
		: "${cinza=$(tput setab 8)}"
		: "${laranja=$(tput setab 202)}"
		: "${roxa=$(tput setab 125)}"
		: "${violeta=$(tput setab 61)}"

		: "${COL_NC='\e[0m'}" # No Color
		: "${COL_LIGHT_GREEN='\e[1;32m'}"
		: "${COL_LIGHT_RED='\e[1;31m'}"
		: "${DONE="${COL_LIGHT_GREEN} done!${COL_NC}"}"
		: "${OVER="\\r\\033[K"}"
		: "${DOTPREFIX="  ${black}::${reset} "}"
		: "${clrkey=${light_white}}"
		: "${TICK="${clrkey}[${green}✓✓✓${clrkey}]${rst}"}"
		: "${CROSS="${clrkey}[${red}✗✗✗${clrkey}]${rst}"}"
		: "${MID="${clrkey}[${red}✗✗${green}✓${clrkey}]${rst}"}"
		: "${WARN="${clrkey}[${yellow}⚠  ${clrkey}]${yellow}"}"
		: "${INFO="${clrkey}[${yellow}➡  ${clrkey}]${rst}"}"

		# dialog colors
		REVERSE="\Zr"
		UNDERLINE="\Zu"
		BOLD="\Zb"
		RESET="\Zn"
		BLACK="\Z0"
		YELLOW="\Z3"
		AMARELO="\Zb\Z3"
		WHITE="\Z7"
		BLUE="\Z4"
		AZUL="\Zb\Z4"
		CYAN="\Z6"
		RED="\Z1"
		GREEN="\Z2"
		MAGENTA="\Z5"
	else
		sh_unsetvarcolors
	fi
}

sh_unsetvarcolors() {
	unset RED GREEN YELLOW BLUE PURPLE CYAN NC RESET BOLD
	unset reset rst bold underline nounderline reverse
	unset black red green yellow blue magenta cyan white gray orange purple violet
	unset light_red light_green light_yellow light_blue light_magenta light_cyan light_white
	unset preto vermelho verde amarelo azul roxo ciano branca cinza laranja roxa violeta
	TICK="${white}[${verde}✓${rst}${white}]${rst}"
	CROSS="${white}[${roxa}✗${rst}${white}]${rst}"
	INFO="${white}[${cinza}i${rst}${white}]${rst}"
}

sh_setlogprefix() {
	NORMAL="${reset}"
	SUCCESS="${green}"
	WARNING="${yellow}"
	FAILURE="${red}"
	INFO="${cyan}"
	BRACKET="${blue}"
	BMPREFIX=""
	DOTPREFIX="  ${blue}::${reset} "
	SUCCESS_PREFIX="${SUCCESS}  ↑  ${NORMAL}"
	SUCCESS_SUFFIX="${BRACKET}[${SUCCESS}  OK  ${BRACKET}]${NORMAL}"
	FAILURE_PREFIX="${FAILURE}  ↓  ${NORMAL}"
	FAILURE_SUFFIX="${BRACKET}[${FAILURE} FAIL ${BRACKET}]${NORMAL}"
	WARNING_PREFIX="${WARNING}  W  ${NORMAL}"
	WARNING_SUFFIX="${BRACKET}[${WARNING} WARN ${BRACKET}]${NORMAL}"
	SKIP_PREFIX="${INFO}  S  ${NORMAL}"
	SKIP_SUFFIX="${BRACKET}[${INFO} SKIP ${BRACKET}]${NORMAL}"
	WAIT_PREFIX="${WARNING}  R  ${NORMAL}"
	WAIT_SUFFIX="${BRACKET}[${WARNING} WAIT ${BRACKET}]${NORMAL}"
}

strzero() {
	printf "%0*d" "$2" "$1"
}

print_step() {
	CURRENT_STEP=$((CURRENT_STEP + 1))
	info_msg "[${CURRENT_STEP}/${STEP_COUNT}] $@"
}

info_msg() {
	printf "\033[1m$@\n\033[m"
}

log_msg() { echo -e "${INFO} ${*}${reset}"; }
log_ok() { echo -e "${TICK} ${*}${reset}"; }
log_err() { echo -e "${CROSS} ${*}${reset}"; }
log_mid() { echo -e "${MID} ${*}${reset}"; }
log_warn() { echo -e "${WARN} ${*}${reset}"; }
msg_tab() { echo -e "  ${INFO} ${*}${reset}"; }
log_ok_tab() { echo -e "  ${TICK} ${*}${reset}"; }
log_err_tab() { echo -e "  ${CROSS} ${*}${reset}"; }
log_mid_tab() { echo -e "  ${MID} ${*}${reset}"; }
log_warn_tab() { echo -e "  ${WARN} ${*}${reset}"; }

sh_setambiente() {
	readonly true=1
	readonly false=0
	readonly err_fatal=$true
	readonly err_not_fatal=$false
	readonly BOOTLOG="/tmp/$APP-$(sh_diahora).log"
	: "${ccabec="$APP v${_VERSION_}"}"
	: "${DIALOG=${DIALOG:-"dialog"}}"

	# flag dialog exit status codes
	: "${D_OK=0}"
	: "${D_CANCEL=1}"
	: "${D_HELP=2}"
	: "${D_EXTRA=3}"x
	: "${D_ITEM_HELP=4}"
	: "${D_ESC=255}"

	# dialog colors
	: "${BLACK="\Z0"}"
	: "${GREEN="\Z2"}"
	: "${YELLOW="\Z3"}"
	: "${BLUE="\Z4"}"
	: "${MAGENTA="\Z5"}"
	: "${WHITE="\Z7"}"
	: "${REVERSE="\Zr"}"
	: "${UNDERLINE="\Zu"}"
	CYAN="\Z6"
	RED="\Z1"
	BOLD="\Zb"
	RESET="\Zn"
	: echo "$err_fatal"

	if [ -z "${COLUMNS}" ]; then
		COLUMNS=$(stty size)
		COLUMNS=${COLUMNS##* }
	fi
	if [ "${COLUMNS}" = "0" ]; then
		COLUMNS=80
	fi
	COL=$((COLUMNS - 8))
	SET_COL="\\033[${COL}G" # at the $COL char
	CURS_ZERO="\\033[0G"
}

sh_disableprintk() {
	if [ -w /proc/sys/kernel/printk ]; then
		echo 0 >/proc/sys/kernel/printk
	fi
}

sh_enableprintk() {
	if [ -w /proc/sys/kernel/printk ]; then
		echo 4 >/proc/sys/kernel/printk
	fi
}

sh_setascii_lines() {
	if [[ "$LANG" =~ 'UTF-8' ]]; then
		export NCURSES_NO_UTF8_ACS=0
	else
		export NCURSES_NO_UTF8_ACS=1
	fi
}

sh_checkroot() {
	((EUID != 0)) && elevate_to_root "$@" || return 0
}

elevate_to_root() {
	log_err "This script must be run as root. Elevating privileges..."
	ccabec+='root [elevated]'
	# Tenta usar sudo primeiro (caso esteja configurado)
	if command -v sudo >/dev/null 2>&1; then
		exec sudo bash "$0" "$@"
	fi
	# Se sudo falhar, tenta su
	if command -v su >/dev/null 2>&1; then
		exec su -c "$0 $*"
	fi
	die "Error: Unable to elevate privileges. Run manually as root."
}

sh_checkDependencies() {
	local d
	local errorFound=0
	declare -a missing

	for d in "${DEPENDENCIES[@]}"; do
		[[ -z $(command -v "$d") ]] && missing+=("$d") && errorFound=1 && printf '%s\n' "${red}${cmsg_ERRO}${reset}: ${cmsg_CommandNotFound} ${cyan}'$d'${reset}"
	done
	if ((errorFound)); then
		echo "${yellow}--------------${cmsg_ImpossivelContinuar}-------------${reset}"
		echo "${cmsg_ImpossivelContinuar1}" >&2
		echo "${cmsg_ImpossivelContinuar2} \$PATH" >&2
		echo "${yellow}-----------------------------------------------${reset}"

		if [[ "$distro" != @(void|void-live|voidlinux) ]]; then
			echo
			if readconf "${yellow}${cmsg_InstCommand} '${cyan}${missing[*]}${reset}'?"; then
				if xbps-install -S "${missing[@]}"; then
					die "${cmsg_RunNew}"
				else
					die "${cmsg_RunNewErro}"
				fi
			fi
		fi
		die "${cmsg_ERRO}: ${cmsg_InstalacaoAbortada}..."
	fi
}

replicate() {
	local Var
	printf -v Var %"$2s" " "
	echo "${Var// /$1}"
}

DOT() {
	printf "%s" "${blue}:: ${reset}"
}

msg() {
	((++ncontador))
	logmessage=$(sed 's/\\\033[^a-zA-Z]*.//g' <<<"$last_msg")
	printf "%s\n" "$(timespec) [ INFO ]${2}" >>"$BOOTLOG"

	if ((grafico)); then
		${DIALOG} \
			--no-collapse \
			--title "$1" \
			--backtitle "$ccabec" \
			--infobox "\n$2" \
			8 60
	else
		log_info_msg "$(fmt) $2"
	fi
}

fmt() {
	printf "${bold}${yellow}%03d/%03d${reset}" "$ncontador" "$ncontador"
	return $?
}

log_info_msg() {
	last_msg="$*"

	if ! ((quiet)); then
		echo -n -e "${BMPREFIX}${@}"
	fi
	return 0
}

evaluate_retval() {
	local error_value="$?"
	local error_fatal="$2"
	local cmsgdie="$3"

	[[ -z "$error_fatal" ]] && error_fatal=$true

	if [ $# -gt 0 ]; then
		error_value="$1"
	fi

	if [ "${error_value}" = 0 ]; then
		log_success_msg ''
	else
		log_failure_msg ''
	fi

	if ((error_value)); then
		if ((error_fatal)); then
			if [[ -z "$cmsgdie" ]]; then
				die "${cmsg_InstalacaoAbortada}..."
			else
				die "$cmsgdie"
			fi
		fi
	fi
	return "${error_value}"
}

log_failure_msg() {
	if ! ((quiet)); then
		echo -n -e "${BMPREFIX}${@}"
		echo -e "${CURS_ZERO}${FAILURE_PREFIX}${SET_COL}${FAILURE_SUFFIX}"
	fi
	logmessage=$(sed 's/\\\033[^a-zA-Z]*.//g' <<<"$last_msg")
	printf "%s\n" "$(timespec) [ FAIL ]${logmessage}" >>"$BOOTLOG"
	replicate "#" "100" >>"$BOOTLOG"
	return 0
}

log_success_msg() {
	if ! ((quiet)); then
		echo -n -e "${BMPREFIX}${@}"
		echo -e "${CURS_ZERO}${SUCCESS_PREFIX}${SET_COL}${SUCCESS_SUFFIX}"
	fi
	logmessage=$(sed 's/\\\033[^a-zA-Z]*.//g' <<<"$last_msg")
	printf "%s\n" "$(timespec) [  OK  ]${logmessage}" >>"$BOOTLOG"
	replicate "#" "100" >>"$BOOTLOG"
	return 0
}

timespec() {
	STAMP="$(date +"%b %d %T %:z") $(hostname)"
	echo "$STAMP"
	return 0
}

die() {
	if test $# -ge 2; then
		evaluate_retval 1
	fi
	local msg=$1
	shift
	printf "%-75s\n" "$(DOT)${bold}${red}$msg${reset}" >&2
	sh_enableprintk
	exit 1
}

conf() {
	xtitle="$1"
	shift
	${DIALOG} \
		--colors \
		--title "$xtitle" \
		--backtitle "$ccabec" \
		--yes-label "${cmsg_yeslabel}" \
		--no-label "${cmsg_nolabel}" \
		--yesno "$*" \
		8 75
	nchoice=$?
	return "$nchoice"
}

readconf() {
	local pNo="${cmsg_nolabel:0:1}"
	local pYes="${cmsg_yeslabel:0:1}"
	local prompt="[$pYes/${pNo,,}]"
	local ctype='S'
	local lEmpty=$false
	local lNo=$true
	local lYes=$false

	if test $# -ge 2; then
		ctype="$2"
		[[ "$ctype" = 'N' ]] && {
			prompt="[$pNo/${pYes,,}]"
			lEmpty=$true
			lNo=$true
			lYes=$false
		}
	fi

	read -r -p "$1 $prompt"
	[[ ${REPLY^} == "" ]] && return "$lEmpty"
	[[ ${REPLY^} == "$pNo" ]] && return "$lNo"
	[[ ${REPLY^} == "$pYes" ]] && return "$lYes" || return "$lNo"
}

readnotconf() {
	readconf "$1" 'N'
}

info() {
	${DIALOG} \
		--colors \
		--title "$1" \
		--backtitle "$ccabec" \
		--ok-label "${cmsg_ok}" \
		--msgbox "$2\n$3\n$4\n$5\n$6" \
		0 0
}

display_result() {
	${DIALOG} \
		--colors \
		--title "$2" \
		--backtitle "$ccabec" \
		--no-collapse \
		--no-cr-wrap \
		--no-nl-expand \
		--ok-label "${cmsg_ok}" \
		--msgbox "$1" \
		15 100
}

alerta() {
	log_success_msg "$@"
	${DIALOG} \
		--title "$1" \
		--backtitle "$ccabec" \
		--ok-label "${cmsg_ok}" \
		--msgbox "$2\n$3\n$4\n$5\n$6" \
		10 60
}

notconf() {
	xtitle="$1"
	shift
	${DIALOG} \
		--colors \
		--title "$xtitle" \
		--backtitle "$ccabec" \
		--yes-label "${cmsg_nolabel}" \
		--no-label "${cmsg_yeslabel}" \
		--yesno "$*" \
		10 100
	return $?
}

sh_diahora() {
	DIAHORA=$(date +"%d%m%Y-%T" | sed 's/://g')
	printf "%s\n" "$DIAHORA"
}

now() {
	printf "%(%m-%d-%Y %H:%M:%S)T\n" "$(date +%s)"
}

sh_timedatectl() {
	local _localtime

	if [[ -n $(command -v timedatectl) ]]; then
		_localtime=$(awk '{print $3}' <(grep 'Time zone' <(timedatectl)))
		if [[ -n "$_localtime" ]]; then
			echo "$_localtime"
			return 0
		fi
	else
		_localtime=$(cut -d'"' -f2 <(grep TIMEZONE /etc/rc.conf))
		if [[ -n "$_localtime" ]]; then
			echo "$_localtime"
			return 0
		fi
	fi
	return 1
}

sh_version() {
	printf "%s\n" "${bold}${cyan}${0##*/} v${_VERSION_}${reset}"
}

strtoarray() {
	local anew
	IFS=' ' read -r -a anew <<<"$1"
	echo "${anew[@]}"
}

lenarraystr() {
	local new=$1
	read -ra ADDR <<<"$new"
	echo "${#ADDR[@]}"
}

scrend() {
	exit "$1"
}

sh_setlanguage() {
	cmsg_LABEL1="$(gettext "Usar as setas ↑ e ↓ para navegar")"
	cmsg_LABEL2="$(gettext "Usar TAB para alternar entre os botões")"
	cmsg_LABEL3="$(gettext "Usar BARRA DE ESPAÇO para selecionar/marcar")"
	cmsg_LABEL4="$(gettext "Usar ENTER para aceitar/executar")"
	cmsg_MENU="${cmsg_LABEL1}\n${cmsg_LABEL3}\n${cmsg_LABEL2}\n${cmsg_LABEL4}"
	cmsg_ERRO="$(gettext "ERRO")"
	cmsg_operRoot="$(gettext "erro: você não pode realizar esta operação a menos que seja root.")"
	cmsg_ImpossivelContinuar="$(gettext "IMPOSSÍVEL CONTINUAR")"
	cmsg_ImpossivelContinuar1="$(gettext "Esse script precisa dos comandos listados acima")"
	cmsg_ImpossivelContinuar2="$(gettext "Instale-os e/ou verifique se estão no seu")"
	cmsg_InstCommand="$(gettext "Instalar o(s) comando(s)")"
	cmsg_RunNew="$(gettext "INFO: Rode novamente o aplicativo")"
	cmsg_RunNewErro="$(gettext "ERRO na instalação dos comandos. Tente manualmente.")"
	cmsg_InstalacaoAbortada="$(gettext "Instalação abortada")"
	cmsg_ok="$(gettext "Ok")"
	cmsg_yeslabel="$(gettext "Sim")"
	cmsg_nolabel="$(gettext "Não")"
	cmsg_descMirror="$(gettext "Escolher espelho")"
	cmsg_Aceitar="$(gettext "Aceitar")"
	cmsg_Sair="$(gettext "Sair")"
	cmsg_Services="$(gettext "gerenciador de serviços")"
	cmsg_servicosInstalados="$(gettext "Aguarde... Verificando serviços instalados")"
	cmsg_servicosAtivos="$(gettext "Aguarde... Verificando serviços ativos")"
	cmsg_servicosnotfound="$(gettext "Nenhum serviço foi encontrado em")"
	cmsg_welcome="$(gettext "Bem-vindo ao $APP")"
	cmsg_Idioma="$(gettext "Escolha idioma")"
	cmsg_Desativar="$(gettext "Desativar")"
	cmsg_Ativar="$(gettext "Ativar")"
	cmsg_ParandoServico="$(gettext "Parando serviço")"
	cmsg_AtivandoServico="$(gettext "Ativando serviço")"
	cmsg_IniciandoServico="$(gettext "Iniciando serviço")"
	cmsg_DesativandoServico="$(gettext "Desativando serviço")"
}

sh_disableServices() {
	local service

	grafico=0
	for service in "${_SERVICES[@]}"; do
		sh_cmd_job "${cmsg_ParandoServico} $service" "sv stop $service" "$err_not_fatal"
		sh_cmd_job "${cmsg_DesativandoServico} $service" "rm -f /var/service/$service" "$err_not_fatal"
	done
}

sh_splitarray() {
	local str="$1"
	local pos="$2"
	local sep="${3:-'|'}"
	local array

	[[ $# -eq 3 && "$pos" = "|" && "$sep" =~ ^[0-9]+$ ]] && {
		sep="$2"
		pos="$3"
	}
	[[ $# -eq 2 && "$pos" = "$sep" ]] && {
		sep="$pos"
		pos=1
	}
	[[ $# -eq 1 || ! "$pos" =~ ^[0-9]+$ ]] && { pos=1; }

	IFS="$sep" read -r -a array <<<"$str"
	echo "${array[pos - 1]}"
}

sh_cmd_job() {
	local cmsg="$1"
	local cjob="$2"
	local erro_fatal="$3"
	local lretval=0

	msg "INFO" "$cmsg"
	$cjob >>"$BOOTLOG" 2>&1
	evaluate_retval "$?" "$err_not_fatal"
	#	return "$?"
}

sh_enableServices() {
	local service

	# To enable a service on a booted system, create a symlink to the service directory in /var/service/:
	# ln -s /etc/sv/<service> /var/service/

	# If the system is not currently running, the service can be linked directly into the default runsvdir:
	# ln -s /etc/sv/<service> /etc/runit/runsvdir/default/
	# This will automatically start the service. Once a service is linked it will always start on boot and restart if it stops, unless administratively downed.
	# To prevent a service from starting at boot while allowing runit to manage it, create a file named down in its service directory:
	# touch /etc/sv/<service>/down

	for service in "${_SERVICES[@]}"; do
		sh_cmd_job "${cmsg_ParandoServico} $service" "sv stop $service" "$err_not_fatal"
		sleep 1
		#		sh_cmd_job "${cmsg_AtivandoServico} $service"  "ln -sf /etc/sv/$service /var/service/" "$err_not_fatal"
		sh_cmd_job "${cmsg_AtivandoServico} $service" "ln -sf /etc/sv/$service /etc/runit/runsvdir/default/" "$err_not_fatal"
		sh_cmd_job "${cmsg_IniciandoServico} $service" "sv start $service" "$err_not_fatal"
		sleep 1
	done
}

sh_disableServices() {
	local service

	for service in "${_SERVICES[@]}"; do
		sh_cmd_job "${cmsg_ParandoServico} $service" "sv stop $service" "$err_not_fatal"
		#		sh_cmd_job "${cmsg_DesativandoServico} $service" "rm -f /var/service/$service" "$err_not_fatal"
		sh_cmd_job "${cmsg_DesativandoServico} $service" "touch /etc/sv/$service/down" "$err_not_fatal"
		sleep 1
	done
	display_result "$(sv status ${_SERVICES[@]})"
}

sh_chooseservices() {
	while true; do
		declare -A Aflag
		declare -a aservices
		declare -A Asv
		local array
		local x
		local sep="\xe2\x94\x82"
		local nconta=0
		local nc=0

		msg "** SERVICES **" "$(log_info_msg "${cmsg_servicosInstalados}")"
		if pushd '/etc/sv/' >>"$BOOTLOG" 2>&-; then
			evaluate_retval "$?" "$err_not_fatal"
			aservices=($(ls))
		else
			evaluate_retval "$?" "$err_not_fatal"
			popd >>"$BOOTLOG" 2>&1
		fi

		nconta="${#aservices[@]}"
		if ! ((nconta)); then
			info "** SERVICES **" "\n${RED}${cmsg_servicosnotfound} /etc/sv/${RESET}"
			info_msg "${red}${cmsg_InstalacaoAbortada}...${reset}"
			cleanup
		fi

		nc=0
		msg "** SERVICES **" "$(log_info_msg "${cmsg_servicosAtivos}")"
		for x in "${aservices[@]}"; do
			if sv status /etc/runit/runsvdir/current/"$x" >>"$BOOTLOG"; then
				status=$(sv status /etc/runit/runsvdir/current/"$x" | cut -d: -f1,3)
				Asv+=([$nc]="$x|Active|$status")
			else
				Asv+=([$nc]="$x|Disabled|")
			fi
			((++nc))
		done
		evaluate_retval "$?" "$err_not_fatal"

		array=()
		((--nconta))
		for x in $(seq 0 $nconta); do
			array+=("$(sh_splitarray "${Asv[$x]}" 1)" "$(printf "$sep%-8s$sep%-40s" "$(sh_splitarray "${Asv[$x]}" 2)" "$(sh_splitarray "${Asv[$x]}" 3)")" "${Aflag[$x]}")
		done

		while true; do
			service=$(${DIALOG} \
				--title "** ${cmsg_Services^^} **" \
				--backtitle "$ccabec" \
				--colors \
				--clear \
				--cancel-label "${cmsg_Sair}" \
				--ok-label "${cmsg_Ativar}" \
				--extra-button --extra-label "${cmsg_Desativar}" \
				--checklist "${cmsg_MENU}" \
				22 0 30 "${array[@]}" 2>&1 >/dev/tty)

			exit_status=$?
			_SERVICES=($(strtoarray "$service"))
			case $exit_status in
			"$D_ESC" | "$D_CANCEL")
				return
				;;
			"$D_OK")
				((${#_SERVICES[@]} >= 1)) && {
					sh_enableServices "$@"
					break
				}
				;;
			3)
				((${#_SERVICES[@]} >= 1)) && {
					sh_disableServices "$@"
					break
				}
				;;
			esac
			info "** ${cmsg_Services^^} **" "\n\n$(gettext 'Use barra de espaço para marcar/escolher.')"
			continue
		done
        continue
	done
}

sh_setambiente
sh_setlanguage
sh_setvarcolors
sh_setascii_lines
sh_setlogprefix
sh_checkDependencies
sh_disableprintk

[[ "$1" = @(-V|-v|version|-version|--version) ]] && {
	sh_version
	exit $(($# ? 0 : 1))
}
[[ "$1" = @(-g|-G|--grafico) || "$2" = @(-g|-G|--grafico) ]] && grafico=$true
sh_checkroot "$@"
sh_chooseservices "$@"
sh_enableprintk
